"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseClient = void 0;
const lodash_1 = __importDefault(require("lodash"));
const fp_1 = __importDefault(require("lodash/fp"));
const moment_1 = __importDefault(require("moment"));
const qs_1 = __importDefault(require("qs"));
const crypto_1 = require("../../../../crypto/src");
const drop_record_response_1 = require("../types/drop-record-response");
const ledger_sdk_error_1 = require("../types/ledger-sdk-error");
/**
 * A base API client that contains generic functions to make
 * API requests compatible with the ledger API.
 */
class BaseClient {
    apiClient;
    authParams;
    activeLedger;
    links;
    id;
    parentId;
    secure;
    constructor(options) {
        this.apiClient = options.apiClient;
        this.secure = options.secure ?? {};
        this.activeLedger = options.ledger;
    }
    /**
     * Internal function for building request hash
     * based on HTTP request variables.
     *
     * @param requestHashParams Configuration object for request hashing
     * @returns request hash
     */
    buildRequestHash(requestHashParams) {
        const protectedHeaders = this.activeLedger
            ? [
                { name: 'x-ledger', value: this.activeLedger },
                ...requestHashParams.protectedHeaders,
            ]
            : requestHashParams.protectedHeaders;
        const protectedHeadersSuffix = fp_1.default.flow([
            fp_1.default.map((h) => h.name.toLowerCase()),
            fp_1.default.join(','),
            (suffix) => (suffix ? `:${suffix}` : ''),
        ])(protectedHeaders);
        const headers = fp_1.default.flow([
            fp_1.default.map((h) => [h.name, h.value]),
            fp_1.default.fromPairs,
        ])(protectedHeaders);
        const hsh = (0, crypto_1.createHash)({
            method: requestHashParams.method,
            url: requestHashParams.url,
            body: !lodash_1.default.isEmpty(requestHashParams.body) ? requestHashParams.body : null,
            headers: !lodash_1.default.isEmpty(headers) ? headers : null,
        });
        return `${hsh}${protectedHeadersSuffix}`;
    }
    /**
     * Internal function for building the bearer token
     * from Ledger Auth params.
     *
     * @param requestHashParams Configuration object for request hashing
     * @param authParams Params for building JWT
     * @returns the bearer token
     */
    async buildJwt(requestHashParams, authParams = {}) {
        if (lodash_1.default.isEmpty(authParams) &&
            lodash_1.default.isEmpty(this.secure) &&
            lodash_1.default.isEmpty(this.authParams)) {
            return null;
        }
        const params = {
            ...this.secure,
            ...this.authParams,
            ...authParams,
        };
        const iat = Math.floor((0, moment_1.default)().valueOf() / 1000);
        const exp = iat + params.exp;
        const verificationKey = params.kid || params.keyPair.public;
        let hsh;
        if (lodash_1.default.isUndefined(params.createHsh) || params.createHsh) {
            hsh = this.buildRequestHash(requestHashParams);
        }
        const jwtPayload = {
            iat,
            exp,
            iss: params.iss,
            aud: params.aud,
            sub: params.sub || verificationKey,
            jti: params.jti || undefined,
            hsh,
        };
        const token = await (0, crypto_1.signJWT)(jwtPayload, params.keyPair.secret, verificationKey);
        return `Bearer ${token}`;
    }
    buildHeaders(token) {
        const authHeaders = token ? { Authorization: token } : {};
        const ledgerHeaders = this.activeLedger
            ? { 'X-Ledger': this.activeLedger }
            : {};
        return {
            ...authHeaders,
            ...ledgerHeaders,
        };
    }
    /**
     * Internal function for creating new ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async createRecord(path, ResponseClass, record, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'POST',
                url: this.createRelativeUrl(path),
                body: record,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.post(path, record, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for ledger records lookup
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async lookupRecord(path, ResponseClass, lookupRecord, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'POST',
                url: this.createRelativeUrl(path),
                body: lookupRecord,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.post(path, lookupRecord, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for activating ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async activateRecord(path, ResponseClass, record, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'POST',
                url: this.createRelativeUrl(path),
                body: record,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.post(path, record, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for updating ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async updateRecord(path, ResponseClass, record, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'PUT',
                url: this.createRelativeUrl(path),
                body: record,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.put(path, record, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for creating new ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async signRecord(path, ResponseClass, signature, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'POST',
                url: this.createRelativeUrl(path),
                body: signature,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.post(path, signature, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for droping ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async dropRecord(path, deletionRecord, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'DELETE',
                url: this.createRelativeUrl(path),
                body: deletionRecord,
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.delete(path, { data: deletionRecord, headers });
            return new drop_record_response_1.DropRecordResponse(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for fetching a single ledger record
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async getRecord(path, ResponseClass, authParams) {
        try {
            const token = await this.buildJwt({
                method: 'GET',
                url: this.createRelativeUrl(path),
                body: {},
                protectedHeaders: [],
            }, authParams);
            const headers = this.buildHeaders(token);
            const response = await this.apiClient.get(path, { headers });
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Internal function for fetching a list of ledger records
     * and enforcing the correct types on axios.
     *
     * @param path API path to call
     * @returns the API response
     */
    async getRecordsList(path, ResponseClass, params) {
        try {
            /**
             * Build axios configuration beforehand so we can resolve
             * the path including the query parameters with the proper
             * serializer.
             */
            const axiosConfig = {
                params,
                /**
                 * @see {@link https://github.com/axios/axios/#request-config}
                 */
                paramsSerializer: {
                    serialize: (params) => {
                        /**
                         * Expected format by GCP is "brackets" instead of dot notation.
                         * Also, qs stringify properly encodes the brackets while
                         * axios doesn't by default, that's why we use it here.
                         *
                         * @see {@link https://github.com/axios/axios/issues/3316}
                         */
                        return qs_1.default.stringify(params, { allowDots: true });
                    },
                },
            };
            const resolvedUrl = this.createRelativeUrl(path, axiosConfig);
            const token = await this.buildJwt({
                method: 'GET',
                url: resolvedUrl,
                body: {},
                protectedHeaders: [],
            }, params?.authParams);
            axiosConfig.headers = this.buildHeaders(token);
            const response = await this.apiClient.get(path, axiosConfig);
            return new ResponseClass(response);
        }
        catch (error) {
            throw new ledger_sdk_error_1.LedgerSdkError(error);
        }
    }
    /**
     * Resolves the path before sending the request in order
     * to generate the correct JWT
     *
     * @param {string} url url to be resolved
     * @param {AxiosRequestConfig} [config] axios request configuration
     * that will be used to send the request
     * @returns {string} resolved path
     */
    createRelativeUrl(url, config) {
        return decodeURIComponent(this.apiClient.getUri({
            url,
            ...config,
        }));
    }
    /**
     * Set config params to build authentication Jwt
     *
     * @param authParams jwt configuration
     */
    setAuthParams(authParams) {
        this.authParams = lodash_1.default.cloneDeep(authParams);
        if (this.links) {
            for (const link of this.links) {
                link.setAuthParams(authParams);
            }
        }
    }
    /**
     * Sets active ledger
     * @param handle active ledger handle
     */
    setActiveLedger(handle) {
        this.activeLedger = handle;
        if (this.links) {
            for (const link of this.links) {
                link.setActiveLedger(handle);
            }
        }
    }
    /**
     * Gets active ledger
     * @returns active ledger handle
     */
    getActiveLedger() {
        return this.activeLedger;
    }
    /**
     * Asserts the client doesn't have
     * an active ledger set in context
     * @throws {LedgerSdkError}
     */
    assertSingleTenant() {
        if (this.activeLedger) {
            throw new ledger_sdk_error_1.LedgerSdkError(new Error('Active ledger should not be set in context'));
        }
    }
    /**
     * Asserts the client has
     * an active ledger set in context
     * @throws {LedgerSdkError}
     */
    assertMultiTenant() {
        if (!this.activeLedger) {
            throw new ledger_sdk_error_1.LedgerSdkError(new Error('Active ledger should be set in context'));
        }
    }
    /**
     * Creates a new instance of the client and sets
     * the id to the context.
     *
     * @param id
     */
    with(id) {
        const clone = lodash_1.default.cloneDeep(this);
        clone.setId(id);
        return clone;
    }
    /**
     * Sets record identifier to context.
     *
     * This method is also responsible for updating
     * the parent id of their linked clients.
     *
     * @param id
     */
    setId(id) {
        this.id = id;
        if (this.links) {
            for (const link of this.links) {
                link.setParentId(id);
            }
        }
        return this;
    }
    /**
     * Sets parent client record id to context
     *
     * @param id
     */
    setParentId(id) {
        this.parentId = id;
    }
    /**
     * Ensures parent id is set
     *
     * @returns parent id
     */
    assertParentId() {
        if (!this.parentId) {
            throw new ledger_sdk_error_1.LedgerSdkError(new Error(`Missing parent record identifier`));
        }
        return this.parentId;
    }
    /**
     * Ensures id is set
     *
     * @returns id
     */
    assertId() {
        if (!this.id) {
            throw new ledger_sdk_error_1.LedgerSdkError(new Error(`Missing record identifier`));
        }
        return this.id;
    }
}
exports.BaseClient = BaseClient;
//# sourceMappingURL=base-client.js.map