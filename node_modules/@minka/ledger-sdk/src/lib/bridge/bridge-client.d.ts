/**
 * @module Clients / Bridges
 * @category Entities
 */
import { AxiosResponse } from 'axios';
import { BridgeActivationOptions, JwtConfig, LedgerBridge, LedgerIdentifier, LedgerPagedList, LedgerRecord } from "../../../types/src";
import { BaseChangeClient } from '../common/clients/base-change-client';
import { BaseClient, BaseClientOptions } from '../common/clients/base-client';
import { CreateRecordBuilder } from '../common/services/create-record-builder';
import { UpdateRecordBuilder } from '../common/services/update-record-builder';
import { BaseRecordResponse } from '../common/types/base-record-response';
import { BaseResponse } from '../common/types/base-response';
import { LedgerListParams } from '../common/types/list-params';
import { BaseListResponse } from '../common/types/list-response';
import { ActivateBridgeBuilder } from './activate-bridge-builder';
/**
 * Single bridge API response.
 */
export declare class BridgeResponse extends BaseRecordResponse<LedgerBridge> {
    /**
     * Record data extracted from the `data` property of the response body.
     */
    bridge: LedgerBridge;
    constructor(response: AxiosResponse<LedgerRecord<LedgerBridge>, LedgerRecord<LedgerBridge>>);
}
/**
 * Bridge activation API response.
 */
export declare class BridgeActivationResponse extends BaseResponse {
}
/**
 * Bridges list API response.
 */
export declare class BridgesResponse extends BaseListResponse<LedgerBridge> {
    /**
     * A flattened list of records, extracted from the `data` property of
     * each record returned.
     */
    bridges: LedgerBridge[];
    constructor(response: AxiosResponse<LedgerPagedList<LedgerBridge>, void>);
}
/**
 * Allows querying and managing bridges.
 *
 * @see {LedgerBridge}
 */
export declare class BridgeClient extends BaseClient {
    /**
     * Allows querying changes.
     *
     */
    change: BaseChangeClient<LedgerBridge>;
    constructor(options: BaseClientOptions);
    /**
     * Initializes a builder instance that supports chaining to make it
     * easier to work with ledger records. You can pass the record
     * payload to this method to use as initial content, this is useful
     * when you already have an object ready, for example when validating
     * API responses or modifying an existing record. An empty record is
     * going to be created if no initial data is provided.
     *
     * @see {LedgerBridge}
     * @see {CreateRecordBuilder}
     * @param record initial record payload (optional)
     * @returns a builder instance
     */
    init(record?: Partial<LedgerRecord<LedgerBridge>>): CreateRecordBuilder<LedgerBridge, BridgeResponse, import("../../../types/src").LedgerMeta<import("../../../types/src").LedgerSignatureCustom>>;
    /**
     * Initializes a builder instance for updating existing records.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the new record payload to this
     * method to use as initial content.
     *
     * @param record initial record payload
     * @returns a builder instance
     */
    edit(record: LedgerRecord<LedgerBridge>): UpdateRecordBuilder<LedgerBridge, BridgeResponse, import("../../../types/src").LedgerMeta<import("../../../types/src").LedgerSignatureCustom>>;
    /**
     * Initializes a builder instance for activating existing record.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the new record payload to this
     * method to use as initial content.
     *
     * @param payload initial activation payload
     * @returns a builder instance
     */
    activate(payload: BridgeActivationOptions): ActivateBridgeBuilder;
    /**
     * Initializes a builder instance for updating existing records.
     * The builder supports chaining to make it easier to work with
     * ledger records. You can pass the existing record payload to
     * this method to use as initial content.
     *
     * @see {LedgerBridge}
     * @see {UpdateRecordBuilder}
     * @param record initial record payload
     * @returns a builder instance
     */
    from(record: LedgerRecord<LedgerBridge>): UpdateRecordBuilder<LedgerBridge, BridgeResponse, import("../../../types/src").LedgerMeta<import("../../../types/src").LedgerSignatureCustom>>;
    /**
     * Gets a ledger bridge by identifier (luid or handle).
     *
     * @see {LedgerBridge}
     * @throws {Error} if the bridge doesn't exist or the
     *   current user doesn't have access to this bridge
     * @param id a unique bridge handle
     * @returns a single bridge response with the requested bridge
     */
    read(id: LedgerIdentifier, authParams?: Partial<JwtConfig>): Promise<BridgeResponse>;
    /**
     * Queries bridges from a ledger.
     *
     * @see {LedgerBridge}
     * @param params query parameters
     * @returns bridges list response with all found bridges
     */
    list(params?: LedgerListParams): Promise<BridgesResponse>;
}
