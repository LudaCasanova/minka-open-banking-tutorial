import { LedgerAccess } from '../common/ledger-access';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerHandle } from '../common/ledger-handle';
/**
 * LedgerRequest is a record that is created for all
 * journaled requests in the system which includes all regular
 * Ledger record endpoints and outgoing requests like dispatching
 * of events and two-phase commit messages.
 */
export type LedgerRequest = LedgerBaseData & {
    handle: LedgerHandle;
    schema: RequestSchema;
    record: RequestRecordHandle;
    action: RequestAction;
    source: RequestParticipantHandle;
    target: RequestParticipantHandle;
    params: RequestParams;
    result: RequestResult;
    access: LedgerAccess;
};
/**
 * RequestRecordHandle represents the record that the request refers to
 * and is either just the record type like `walletRequestParticipant`, `intent`, etc.
 * when querying collections or in the format `prefix:handle` when
 * referring to a specific Record.
 */
export type RequestRecordHandle = `${RequestRecord}` | `${RequestRecord}:${LedgerHandle}`;
/**
 * RequestParticipant is the prefix for the RequestParticipantHandle field,
 * except for `unknown` which is used alone when the participant is not known.
 */
export declare enum RequestParticipant {
    Unknown = "unknown",
    Ledger = "ledger",
    Signer = "signer",
    Bridge = "bridge",
    Effect = "effect"
}
/**
 * RequestParticipantHandle represents a source or target or a request. It is
 * of the format `prefix:handle` where prefix can be `ledger`, `signer`,
 * `bridge` or `effect. `ledger` represents the Ledger service and `signer`
 * or `bridge` is determined by the JWT `sub` claim of an incoming request.
 * When dispatching messages `effect` is used and if it is not
 * possible to determine the source or target of a request, the value
 * `unknown` us used.
 */
export type RequestParticipantHandle = `${Exclude<RequestParticipant, RequestParticipant.Unknown>}:${LedgerHandle}` | RequestParticipant.Unknown;
/**
 * RequestSchema represents the type of request that is logged.
 * At the moment we only support REST requests, but additional ones are
 * possible like Kafka.
 */
export declare enum RequestSchema {
    Rest = "rest"
}
/**
 *  RequestRecord is the prefix for the LedgerRequest
 *  record field which has the format prefix:id. In case there is no
 *  specific id like in the case of querying records, just the prefix is used.
 */
export declare enum RequestRecord {
    Ledger = "ledger",
    Signer = "signer",
    Symbol = "symbol",
    Wallet = "wallet",
    Intent = "intent",
    IntentProof = "intent-proof",
    Effect = "effect",
    Bridge = "bridge",
    Circle = "circle",
    CircleSigner = "circle-signer",
    Policy = "policy",
    Schema = "schema",
    Request = "request",
    Anchor = "anchor",
    Domain = "domain",
    AdviceAliasResolve = "advice-alias-resolve",
    LedgerChange = "ledger-change",
    SignerChange = "signer-change",
    SymbolChange = "symbol-change",
    WalletChange = "wallet-change",
    IntentChange = "intent-change",
    EffectChange = "effect-change",
    BridgeChange = "bridge-change",
    CircleChange = "circle-change",
    PolicyChange = "policy-change",
    SchemaChange = "schema-change",
    AnchorChange = "anchor-change",
    Event = "event",
    Entry = "entry"
}
/**
 * RequestAction represents what was done to/with the record.
 * For incoming REST requests Create corresponds to POST, Read to GET,
 * Update to PUT and Query to GET on the collection. Sign and ReadBalance
 * are actions that don't directly correspond to REST methods on the
 * record. The combination of RequestRecord and RequestAction
 * uniquely identify Ledger endpoints. Send is used when dispatching webhook
 * Events while Prepare, Commit and Abort are used for two-phase commit
 * requests.
 */
export declare enum RequestAction {
    Create = "create",
    Read = "read",
    Update = "update",
    Query = "query",
    Lookup = "lookup",
    Drop = "drop",
    ReadBalance = "read-balance",
    ReadLimit = "read-limit",
    QuerySigner = "query-signer",
    AssignSigner = "assign-signer",
    ReadSigner = "read-signer",
    RemoveSigner = "remove-signer",
    Send = "send",
    Prepare = "prepare",
    Commit = "commit",
    Abort = "abort",
    Activate = "activate"
}
/**
 * Parameters of the request.
 */
export type RestParams = {
    /**
     * HTTP request method
     */
    method: string;
    /**
     * HTTP request URL
     */
    url: string;
    /**
     * HTTP request headers
     */
    headers: Record<string, any>;
    /**
     * HTTP request body
     */
    body: string;
    /**
     * Timestamp that represents the time when the request was received by the
     * Ledger for incoming requests or time when the request was sent for
     * outgoing requests.
     */
    moment: Date;
};
/**
 * Response to the request.
 */
export type RestResult = {
    /**
     * HTTP response status code
     */
    status: number;
    /**
     * HTTP response headers
     */
    headers: Record<string, any>;
    /**
     * HTTP response body
     */
    body: string;
    /**
     * Timestamp that represents the time when the response to an incoming
     * request was sent by the Ledger or time when a response was received
     * by the Ledger for outgoing requests.
     */
    moment: Date;
};
/**
 * RequestParams could be different depending on the type of request,
 * but at the moment we only have REST.
 */
export type RequestParams = RestParams;
/**
 * RequestResult could be different depending on the type of request,
 * but at the moment we only have REST.
 */
export type RequestResult = RestResult;
