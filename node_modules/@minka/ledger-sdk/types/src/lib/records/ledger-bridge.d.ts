import { LedgerAccess } from '../common/ledger-access';
import { LedgerCustom } from '../common/ledger-custom';
import { LedgerBaseData } from '../common/ledger-data';
import { LedgerHandle } from '../common/ledger-handle';
/**
 * A bridge represents a ledger configuration record that
 * is used to register remote services with the ledger.
 * This is an optional record in most cases, since remote
 * service calls can usually be specified inline, for
 * example actions in effects, aspects, etc.
 * An example of a bridge is an integration service
 * that connects with a banking core in order to perform
 * debit and credit operations in response to ledger balance
 * movements. Other use cases include services which host webhooks
 * in order to subscribe to ledger events and react to them.
 *
 */
export type LedgerBridge = LedgerBaseData & {
    /**
     * Bridge handle or identifier, handle is used to
     * identify a bridge in our database.
     */
    handle: LedgerHandle;
    /**
     * The schema used to validate this bridge. This is mandatory
     * if there is at least one schema defined for the record
     * type `bridge`.
     */
    schema?: LedgerHandle;
    /**
     * Bridge configuration object
     */
    config: BridgeConfig;
    /**
     *
     */
    secure: BridgeSecurityRule[];
    /**
     * Defines bridge's features enabled.
     * All the traits are enabled by default if
     * this property is not present.
     */
    traits?: BridgeTrait[];
    /**
     * Custom metadata, this object can hold any
     * additional data that could be useful to end users
     * or ledger plugins to work with the bridge.
     */
    custom?: LedgerCustom;
    /**
     * Determines access controls of a bridge. This field
     * can be used to limit updates, issuance, etc.
     */
    access: LedgerAccess;
};
/**
 * Security rules used to define the authentication and
 * authorization mechanisms using to the bridge to connect
 * from and to the ledger.
 */
export type BridgeSecurityRule = {
    schema: string;
    public: string;
    secret: string;
};
/**
 * Bridge configuration object which will be shared
 * across all of the bridge functionalities.
 */
export type BridgeConfig = {
    server?: string;
    /**
     * Determines how bridge calls for debit claims are grouped in case multiple claims of
     * one intent are addressed to the same bridge.
     *
     * If not defined, claims are not grouped
     */
    'debits.claims.groupBy'?: BridgeClaimGrouping;
    /**
     * Determines how bridge calls for credit claims are grouped in case multiple claims of
     * one intent are addressed to the same bridge.
     *
     * If not defined, claims are not grouped
     */
    'credits.claims.groupBy'?: BridgeClaimGrouping;
};
/**
 * Determines how bridge calls for claims are grouped in case multiple claims of
 * one intent are addressed to the same bridge.
 */
export declare enum BridgeClaimGrouping {
    /**
     * With this option, claims will be grouped by exact address of `target.handle` of the claims.
     *
     * If there are multiple claims with the same target address,
     * they will be grouped into single credit entry sent to a target bridge.
     */
    address = "address",
    /**
     * With this option, claims will be grouped by the actual wallet resolved as target of the address
     * from `target.handle`
     *
     * If there are multiple claims with different `target.handle`,
     * but they get resolved to the same target wallet (e.g. because of wallet parent hierarchy),
     * these claims will be grouped together.
     *
     * Of course, if the `target.handle` is the same, then the claims will also be grouped together,
     * just like they would have with the `address` grouping setting.
     */
    wallet = "wallet"
}
/**
 * Features of a bridge.
 */
export declare enum BridgeTrait {
    Debits = "debits",
    Credits = "credits",
    /**
     * Can receive intent status calls
     */
    Statuses = "statuses",
    Anchors = "anchors",
    Domains = "domains",
    Effects = "effects"
}
/**
 * Legacy bridge features mapped to their newest versions.
 * If a bridge has a legacy trait enabled, its corresponding
 * non-legacy trait is also considered to be enabled.
 */
export declare const LegacyBridgeTrait: {
    effects: string;
};
export declare const BridgeTraits: BridgeTrait[];
export type BridgeActivationOptions = {
    /**
     * Time in minutes to resume events from.
     */
    offset?: number;
};
