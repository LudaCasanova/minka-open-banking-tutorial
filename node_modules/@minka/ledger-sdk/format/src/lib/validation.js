"use strict";
// This file contains validator functions that can be used
// to validate user input in commands. Functions return void
// if the provided value is valid, or throw an Error if the
// value isn't valid.
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertIsSecretKey = exports.assertIsPublicKey = exports.isLuid = exports.assertContains = exports.assertValidUrl = exports.assertOptionsSelected = exports.assertValidWithFactor = exports.assertPowerOf10 = exports.assertLessThanOrEqual = exports.assertGreaterThanOrEqual = exports.assertGreaterThan = exports.assertNumber = exports.assertValidIdentifier = exports.FIELD_NAME_REGEX = exports.LUID_REGEX = exports.ADDRESS_REGEX = exports.HANDLE_REGEX = exports.assertNotEmptyString = void 0;
const bignumber_js_1 = require("bignumber.js");
/**
 * Asserts that a value isn't an empty string.
 *
 * @param value value to validate
 */
function assertNotEmptyString(value, errorMessage) {
    if (typeof value !== 'string' || value === '') {
        throw new Error(errorMessage || `Value cannot be empty.`);
    }
}
exports.assertNotEmptyString = assertNotEmptyString;
// Regular expressions below are reused, be careful if
// you decide to add /g flag, because regex would become
// stateful in that case and could work unreliably.
/**
 * Regular expression which matches record handle.
 *
 * Handle can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, :, ., =, $, /, @. Handle should not
 * start with `$<3 letters>.` prefix because this pattern is designated
 * for LUID.
 */
exports.HANDLE_REGEX = /^(?!\$[a-z]{3}\.)[a-zA-Z0-9_\-:.=$/@]+$/;
/**
 * Regular expression which matches the address used in source,
 * target or wallet handle.
 *
 * Address format consists of schema,
 * handle and parent: `[<schema>:]<handle>[@<parent>]`.
 * Schema and parent are optional, but all 3 components
 * can consist only of lowercase and uppercase letters,
 * digits and special characters ., _, - and +.
 *
 * Regex exec result will have 3 named groups where components
 * will be parsed (if present):
 * ```
 * - schema
 * - handle
 * - parent
 * ```
 *
 * @example
 * const result = ADDRESS_REGEX.exec('tran:12345@pbz.hr')
 *
 * if (result) {
 *   const { schema, handle, parent } = result.groups
 * }
 * // { schema: 'tran', handle: '12345', parent: 'pbz.hr' }
 */
exports.ADDRESS_REGEX = /^(((?<schema>[a-zA-Z0-9_\-+.]+):)?(?<handle>[a-zA-Z0-9_\-+.]+))(@(?<parent>[a-zA-Z0-9_\-+.]+))?$/;
/**
 * Regular expression which matches the luid.
 * Its pattern is defined by:
 *
 * `$<3 chars abbreviation of record type>.<17 random chars>`
 *
 * The random chars can be lowercase and uppercase letters, digits,
 * _ and -.
 * @example
 * // for wallets
 * luid: $wlt.7mSVWFKX-Tfx2NsNj
 *
 * @example
 * // for circles
 * luid: $crc.2mLt0MgoHi_DrLr9X
 */
exports.LUID_REGEX = /^\$[a-z]{3}\.[A-Za-z0-9_-]{17}$/;
/**
 * Regular expression which matches the allowed field name
 * used in ledger custom data or filters.
 * Field name can consist of lowercase and uppercase letters, digits,
 * and special characters: _, -, . and it should start only with
 * lowercase letter.
 */
exports.FIELD_NAME_REGEX = /^[a-z][a-zA-Z0-9_\-.]+$/;
/**
 * Validates that a provided value is a valid identifier.
 * Accepts an optional format parameter with the following values:
 *  - handle: identifier of most records in ledger (except wallet)
 *  - address: structured identifier for targeting wallets in intents
 *  - fieldName: field name used in simple maps such as custom data and filters
 *
 * @param value value to validate
 * @param [format=handle] format of the identifier
 */
function assertValidIdentifier(value, format = 'handle') {
    assertNotEmptyString(value);
    switch (format) {
        case 'handle':
            if (!exports.HANDLE_REGEX.test(value)) {
                throw new Error(`Only values with letters, digits, _, -, :, ., =, $, / and @ are allowed and they should not start with '$<3 letters>.' sequence.`);
            }
            break;
        case 'address':
            if (!exports.ADDRESS_REGEX.test(value)) {
                throw new Error(`Value must follow the address format.`);
            }
            break;
        case 'fieldName':
            if (!exports.FIELD_NAME_REGEX.test(value)) {
                throw new Error(`Only values with letters, digits, _, -, and . that start with a lowercase letter are allowed.`);
            }
            break;
    }
}
exports.assertValidIdentifier = assertValidIdentifier;
/**
 * Validates that a provided value is a valid number.
 *
 * @param value value to validate
 */
function assertNumber(value) {
    if (Number.isNaN(value)) {
        throw new Error(`Please enter a valid number.`);
    }
}
exports.assertNumber = assertNumber;
/**
 * Validates that the provided number is larger than the
 * provided min value.
 *
 * @param value value to validate
 * @param minValue min value to compare against
 */
function assertGreaterThan(value, minValue) {
    if (value <= minValue) {
        throw new Error(`Value must be greater than ${minValue}`);
    }
}
exports.assertGreaterThan = assertGreaterThan;
/**
 * Validates that the provided number is larger than or equal the
 * provided min value.
 *
 * @param value value to validate
 * @param minValue min value to compare against
 */
function assertGreaterThanOrEqual(value, minValue) {
    if (value < minValue) {
        throw new Error(`Value must be greater than or equal ${minValue}`);
    }
}
exports.assertGreaterThanOrEqual = assertGreaterThanOrEqual;
/**
 * Validates that the provided number is less than or equal the
 * provided max value.
 *
 * @param value value to validate
 * @param maxValue max value to compare against
 */
function assertLessThanOrEqual(value, maxValue) {
    if (value > maxValue) {
        throw new Error(`Value must be less than or equal ${maxValue}`);
    }
}
exports.assertLessThanOrEqual = assertLessThanOrEqual;
/**
 * Validates that the provided number is power of 10.
 *
 * @param value value to validate
 */
function assertPowerOf10(value) {
    if (Math.log10(value) % 1 !== 0) {
        throw new Error(`Value must be a power of 10`);
    }
}
exports.assertPowerOf10 = assertPowerOf10;
/**
 * Validates that the provided number in integer when multiplied
 * by factor.
 *
 * @param value value to validate
 * @param factor factor to multiply with
 */
function assertValidWithFactor(value, factor) {
    const bnValue = new bignumber_js_1.BigNumber(value).times(new bignumber_js_1.BigNumber(factor));
    // we cannot just multiply value with factor and check if that is an integer
    // as this is vulnerable to bugs in javascript when multiplying floats
    const isValid = bnValue.integerValue().isEqualTo(bnValue);
    if (!isValid) {
        throw new Error(`Smallest unit of amount can be ${1 / factor}`);
    }
}
exports.assertValidWithFactor = assertValidWithFactor;
/**
 * Validates that the correct number of values has been selected. This
 * validator is useful for checkbox style inputs.
 *
 * @param selection selected values
 * @param requiredOptions required number of selected values
 */
function assertOptionsSelected(selection, requiredOptions = 1) {
    if (!selection || selection.length < requiredOptions) {
        throw new Error(`Please select at least ${requiredOptions} option${requiredOptions > 1 ? 's' : ''}`);
    }
}
exports.assertOptionsSelected = assertOptionsSelected;
/**
 * Asserts that a value isn't an empty string.
 *
 * @param value value to validate
 */
function assertValidUrl(url) {
    try {
        new URL(url);
    }
    catch (e) {
        throw new Error(`Value ${url} is not a valid URL.`);
    }
}
exports.assertValidUrl = assertValidUrl;
/**
 * Validates that the provided value exists in the provided
 * array
 *
 * @param value value to validate
 * @param array array to compare against
 */
function assertContains(value, array) {
    if (!array.includes(value)) {
        throw new Error(`Value must be one of ${array.join(', ')}`);
    }
}
exports.assertContains = assertContains;
/**
 * Checks whether a value is a luid pattern string
 *
 * @param value value to be checked
 * @returns
 */
function isLuid(value) {
    return exports.LUID_REGEX.test(value);
}
exports.isLuid = isLuid;
/**
 * Checks whether a value is a valid ed25519-raw public key
 */
function assertIsPublicKey(value) {
    if (!/^[A-Za-z0-9+/]{43}=$/.test(value)) {
        throw new Error(`Value ${value} is not a valid public key.`);
    }
}
exports.assertIsPublicKey = assertIsPublicKey;
/**
 * Checks whether a value is a valid ed25519-raw secret key
 */
function assertIsSecretKey(value) {
    if (!/^[A-Za-z0-9+/]{43}=$/.test(value)) {
        throw new Error(`Value ${value} is not a valid secret key.`);
    }
}
exports.assertIsSecretKey = assertIsSecretKey;
//# sourceMappingURL=validation.js.map