"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.importEncryptedPrivateKey = exports.exportEncryptedPrivateKey = void 0;
const asn1_1 = require("../common/asn1");
/**
 * Exports encrypted key components to pkcs5 formatted string.
 *
 * @param key encrypted key components
 * @returns pkcs formatted string encoded as base64
 */
function exportEncryptedPrivateKey(key) {
    // Iterations number is unsigned int written in 2 bytes, Big-endian
    const iterationsBuffer = Buffer.alloc(2);
    iterationsBuffer.writeUInt16BE(key.iterations);
    const buffer = Buffer.concat([
        Buffer.from(asn1_1.ASN1_PKCS5_SALT_PREFIX, 'hex'),
        key.salt,
        Buffer.from(asn1_1.ASN1_PKCS5_ITERATIONS_PREFIX, 'hex'),
        iterationsBuffer,
        Buffer.from(asn1_1.ASN1_PKCS5_IV_PREFIX, 'hex'),
        key.iv,
        Buffer.from(asn1_1.ASN1_PKCS5_VALUE_PREFIX, 'hex'),
        key.value,
    ]);
    return buffer.toString('base64');
}
exports.exportEncryptedPrivateKey = exportEncryptedPrivateKey;
/**
 * Imports encrypted key components from pkcs5 formatted string.
 *
 * @param key pkcs formatted string encoded as base64
 * @returns encrypted key components
 */
function importEncryptedPrivateKey(key) {
    const payloadAsn1Hex = Buffer.from(key, 'base64').toString('hex');
    const { salt, iterations, iv, value } = (0, asn1_1.parsePkcs5EncryptedKey)(payloadAsn1Hex);
    return {
        salt: Buffer.from(salt, 'hex'),
        // Iterations number is unsigned int written in 2 bytes, Big-endian
        iterations: Buffer.from(iterations, 'hex').readUInt16BE(),
        iv: Buffer.from(iv, 'hex'),
        value: Buffer.from(value, 'hex'),
    };
}
exports.importEncryptedPrivateKey = importEncryptedPrivateKey;
//# sourceMappingURL=format.js.map